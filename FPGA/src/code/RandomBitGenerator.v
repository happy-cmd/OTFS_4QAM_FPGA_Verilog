//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 10? 31 2024 11:13:47
//
//      Input file      : 
//      Component name  : randombitgenerator
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module RandomBitGenerator(Clk, SRst, Start, ModulationOrder, RandomBitValid, RandomBit);
   input            Clk;
   input            SRst;
   input            Start;
   input [2:0]      ModulationOrder;
   output           RandomBitValid;
   reg              RandomBitValid;
   output           RandomBit;
   reg              RandomBit;
   reg         State;
   reg [15:0]       ShiftReg;
   reg [14:0]       BitCount;
   reg [15:0]       NumberOfBits;
   
  
   always @(posedge Clk)
      begin
         if (SRst == 1'b1)
         begin
            State <= 1'b0;
            ShiftReg <= {16{1'b1}};
            RandomBitValid <= 1'b0;
            RandomBit <= 1'b0;
         end
         else
            case (State)
               1'b0 :
                  begin
                     RandomBitValid <= 1'b0;
                     BitCount <= 0;
                     if (Start == 1'b1)
                     begin
                        State <= 1'b1;
                        if (ModulationOrder == 3'b000) // 4-QAM调制
                           NumberOfBits <= ((4096 * 2));
                        else if (ModulationOrder == 3'b001) // 8-QAM调制
                           NumberOfBits <= ((4096 * 3));
                        else if (ModulationOrder == 3'b010) // 16-QAM调制
                           NumberOfBits <= ((4096 * 4));
                        else if (ModulationOrder == 3'b011) // 32-QAM调制
                           NumberOfBits <= ((4096 * 5));
                        else
                           NumberOfBits <= ((4096 * 5));
                     end
                  end
               
               1'b1 :
                  begin
                     ShiftReg <= {(ShiftReg[0] ^ ShiftReg[2] ^ ShiftReg[3] ^ ShiftReg[5]), ShiftReg[15:1]};
                     RandomBitValid <= 1'b1;
                     RandomBit <= (ShiftReg[0] ^ ShiftReg[2] ^ ShiftReg[3] ^ ShiftReg[5]);
                     BitCount <= BitCount + 1;
                     if (BitCount == NumberOfBits - 1)
                        State <= 1'b0;
                  end
               
               default :
                  State <= 1'b0;
            endcase
      end
   
endmodule

